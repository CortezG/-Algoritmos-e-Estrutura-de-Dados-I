#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // Para usar INT_MIN

#define MAX 10

typedef struct {
    int valor;
    int proximo;
} Elemento;

typedef struct {
    Elemento lista[MAX];
    int disponivel;
    int inicio;
} ListaLigada;

void InicializarEstrutura(ListaLigada* m) {
    for (int i = 0; i < MAX; i++) {
        m->lista[i].proximo = i + 1;
    }

    m->lista[MAX - 1].proximo = -1;
    m->disponivel = 0;
    m->inicio = -1;
}

int Tamanho(ListaLigada* m) {
    int tam = 0;
    int atual = m->inicio;
    while (atual != -1) {
        tam++;
        atual = m->lista[atual].proximo;
    }

    return tam;
}

void ExibirLista(ListaLigada* m) {
    int i = m->inicio;
    while (i != -1) {
        printf("%d ", m->lista[i].valor);
        i = m->lista[i].proximo;
    }
    printf("\n");
}

int BuscarElemento(ListaLigada* m, int chave) {
    int atual = m->inicio;
    while (atual != -1 && m->lista[atual].valor != chave) {
        atual = m->lista[atual].proximo;
    }
    return atual;
}

int ObterNo(ListaLigada* m) {
    int livre = m->disponivel;
    if (livre != -1) {
        m->disponivel = m->lista[livre].proximo;
    }
    return livre;
}

int InserirElemento(ListaLigada* m, int novovalor) {
    int i = m->inicio;
    int pos_inserir = -1;

    // caso não tenha espaço livre
    if (m->disponivel == -1) {
        return -1;
    }

    // encontrar a posição para inserir (no final da lista)
    while (i != -1) {
        pos_inserir = i;
        i = m->lista[i].proximo;
    }

    // inserir o elemento
    i = ObterNo(m);
    m->lista[i].valor = novovalor;
    m->lista[i].proximo = -1;

    // se a pos_inserir for -1 significa que a lista está vazia
    if (pos_inserir == -1) {
        m->inicio = i;
    } else {
        m->lista[pos_inserir].proximo = i;
    }

    return 1;
}

void ExcluirElemento(ListaLigada* m, int valor) {
    int pos = m->inicio;
    int pos_anterior = -1;

    while (pos != -1 && m->lista[pos].valor != valor) {
        pos_anterior = pos;
        pos = m->lista[pos].proximo;
    }

    if (pos != -1) {
        if (pos_anterior == -1) {
            m->inicio = m->lista[pos].proximo;
        } else {
            m->lista[pos_anterior].proximo = m->lista[pos].proximo;
        }
        m->lista[pos].proximo = m->disponivel;
        m->disponivel = pos;
    }
}

int EncontrarMaiorElemento(ListaLigada* m) {
    int maiorElemento = INT_MIN;
    int pos = m->inicio;

    while (pos != -1) {
        if (m->lista[pos].valor > maiorElemento) {
            maiorElemento = m->lista[pos].valor;
        }
        pos = m->lista[pos].proximo;
    }

    return maiorElemento;
}

int RemoverMaiorElemento(ListaLigada* m) {
    int maiorElemento = INT_MIN;
    int pos = m->inicio;
    int pos_anterior = -1;
    int posicao_maior = -1;

    while (pos != -1) {
        if (m->lista[pos].valor > maiorElemento) {
            maiorElemento = m->lista[pos].valor;
            posicao_maior = pos;
        }
        pos_anterior = pos;
        pos = m->lista[pos].proximo;
    }

    if (posicao_maior != -1) {
        if (pos_anterior == -1) {
            m->inicio = m->lista[posicao_maior].proximo;
        } else {
            m->lista[pos_anterior].proximo = m->lista[posicao_maior].proximo;
        }
        m->lista[posicao_maior].proximo = m->disponivel;
        m->disponivel = posicao_maior;
    }

    return maiorElemento;
}

int main() {
    ListaLigada lista;
    int opcao, valor;
    InicializarEstrutura(&lista);

    do {
        printf("\nTabela:\n");
        printf("[1] Inserir um elemento\n");
        printf("[2] Exibir lista\n");
        printf("[3] Excluir um elemento\n");
        printf("[4] Buscar um elemento\n");
        printf("[5] Quantidade de elementos\n");
        printf("[6] Encontrar e remover o maior elemento\n");
        printf("[7] Imprimir o maior elemento\n");
        printf("[8] Finalizar\n");
        scanf("%d", &opcao);

        switch (opcao) {
            case 1:
                printf("Insira um valor inteiro: ");
                scanf("%d", &valor);
                if (InserirElemento(&lista, valor) == -1) {
                    printf("Erro: Lista está cheia.\n");
                }
                break;
            case 2:
                ExibirLista(&lista);
                break;
            case 3:
                printf("Digite o valor que deseja excluir: ");
                scanf("%d", &valor);
                ExcluirElemento(&lista, valor);
                break;
            case 4:
                printf("Digite o valor que deseja buscar: ");
                scanf("%d", &valor);
                int posicao = BuscarElemento(&lista, valor);
                if (posicao != -1) {
                    printf("Valor %d encontrado na posição %d.\n", valor, posicao);
                } else {
                    printf("Valor %d não encontrado.\n", valor);
                }
                break;
            case 5:
                printf("Quantidade de elementos na lista: %d\n", Tamanho(&lista));
                break;
            case 6:
                if (Tamanho(&lista) > 0) {
                    int maiorElemento = RemoverMaiorElemento(&lista);
                    printf("Maior elemento removido: %d\n", maiorElemento);
                } else {
                    printf("Lista vazia.\n");
                }
                break;
            case 7:
                if (Tamanho(&lista) > 0) {
                    int maiorElemento = EncontrarMaiorElemento(&lista);
                    printf("Maior elemento da lista: %d\n", maiorElemento);
                } else {
                    printf("Lista vazia.\n");
                }
                break;
            case 8:
                printf("Finalizando...\n");
                break;
            default:
                printf("Opção inválida. Tente novamente.\n");
        }
    } while (opcao != 8);

    return 0;
}
